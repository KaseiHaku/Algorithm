假设待排序数组为：ary = [8,5,2,7,4]
讲解的很好：https://www.cnblogs.com/onepixel/p/7674659.html

排序算法：
    比较类排序：
        交换排序：
            冒泡排序：
                算法：
                    1. 取 ary[0] 和 ary[1] 比较，如果 ary[0] > ary[1] , 那么交换两个数的位置
                    2. 再取 ary[1] 和 ary[2] 比较，如果 ary[1] > ary[2] , 那么交换两个数的位置
                    3. 依次类推，直到最后一个，那么一遍循环后 最后一个就是最大的
                    4. 以 ary[0] 到 ary[length-1] 为新数组，再次执行 1 2 3 直到全部结束
                算法特性：
                    时间复杂度：O(n^2)
                    空间复杂度：O(1)
                    稳定性：稳定
            快速排序：
                算法：
                    1. 选择一个数作为轴值k（一般为第一个数）
                    2. 将剩余的数，小于k的 放在k的 左边，大于k的放在k的右边，那么k的位置就是正确的
                    3. 对k的左右两边的序列重复进行前两步，直到序列中只含有1个元素，则完成排序
                算法特性：
                    时间复杂度：O(nlog2n)
                    空间复杂度：O(nlog2n)
                    稳定性：不稳定
        插入排序：
            直接（简单）插入排序：
                算法：
                    1. 首先认为 ary[0] 是已经排好的序列
                    2. 取 ary[1] 跟 ary[0] 比较，ary[1]>ary[0] 那么 ary[1] 插入到 ary[0] 后面
                    3. 再取 ary[2] 跟已经排好的 ayr[0] ary[1] 依次比较，找到插入位置，找到后插入后该位置，数组其他数据依次后移
                算法特性：
                    时间复杂度：O(n^2)
                    空间复杂度：O(1)
                    稳定性：稳定 
            希尔排序：
                算法：
                    1. 一组数，如军训报数般进行报数，将报数的序数一样的值分到一组，如1到3报数就会分出3组，1的一组，2的一组名，3的一组（报数步长可以自定义，但必须逐步缩小）
                    2. 将分组后的各个小组进行 直接插入排序，然后把每组的第一个抽出来放在一起，第二个也一样，以此类推；最后合并成一个大组
                    3. 将合并后的大组再进行步长小的报数，重复前两步，得到再次合并的大组，那么该大组基本“有序”
                    4. 对该大组进行直接插入排序
                算法特性：
                    时间复杂度：O(n^1.3)
                    空间复杂度：O(1)
                    稳定性：不稳定 
                    
        选择排序：
            简单选择排序：
                算法：
                    1. 从一个序列中选出最小的值放在第一位，
                    2. 从剩下的序列中再选最小值放在第二位
                    3. 重复前两步
                算法特性：
                    时间复杂度：O(n^2)
                    空间复杂度：O(1)
                    稳定性：不稳定 
            堆排序：
                算法：
                    1. 首先将 ary 按照层序，构成一个近似的完全二叉树，前提:每个节点的值都大于(小于)其左右节点的值
                算法特性：
                    时间复杂度：O(nlog2n)
                    空间复杂度：O(1)
                    稳定性：不稳定 
        归并排序：
            二路归并排序：
                算法：
                    1. 将长度为 n 的无序序列，分割成 n/2 个子序列，那么每个子序列个数为 1 或者 2，
                    2. 对每个子序列进行排序，排序算法采用以上任何一种
                    3. 将两个排好序的子序列，合并成一个大的子序列，直到最终再次合并为一个序列
                算法特性：
                    时间复杂度：O(nlog2n)
                    空间复杂度：O(nlog2n)
                    稳定性：稳定
            多路归并排序：
    非比较排序：
        计数排序：
            算法：
                前提：需要确定要排序数的范围
            时间复杂度：O(n+k)
                空间复杂度：O(n+k)
                稳定性：稳定   
        桶排序：
            算法： 
                1. 例如一组数，先根据千位排序，再百位，再个位
            算法特性：
                时间复杂度：O(n+k)
                空间复杂度：O(n+k)
                稳定性：稳定
        基数排序：
            算法：低优先级的先排
            算法特性：
                时间复杂度：O(n*k)
                空间复杂度：O(n+k)
                稳定性：稳定
                    
                    
                    
